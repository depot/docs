---
title: Best practice Dockerfile for Python with poetry
ogTitle: Best practice Dockerfile for Python with poetry
description: A sample best practice poetry Dockerfile for Python from Depot
---

Below is an example `Dockerfile` that we use and recommend at Depot when we are building Docker images for Python applications that use `poetry`as their package manager.

```dockerfile
# syntax=docker/dockerfile:1

FROM python:3.13-alpine AS build

ARG DEPOT_PROJECT=my-app

ENV POETRY_VERSION=1.7.1 \
    POETRY_HOME="/opt/poetry" \
    POETRY_VENV_IN_PROJECT=0 \
    POETRY_NO_INTERACTION=1 \
    POETRY_CACHE_DIR=/tmp/poetry_cache \
    PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PYSETUP_PATH="/opt/pysetup" \
    VENV_PATH="/opt/venv"

ENV PATH="$POETRY_HOME/bin:$VENV_PATH/bin:$PATH"

RUN apk add --no-cache \
    build-base \
    curl \
    git \
    gcc \
    musl-dev \
    libffi-dev \
    pkgconfig

RUN --mount=type=cache,target=/root/.cache,id=${DEPOT_PROJECT}-pip-cache,sharing=locked \
    curl -sSL https://install.python-poetry.org | python - --version $POETRY_VERSION

WORKDIR $PYSETUP_PATH

COPY pyproject.toml ./

RUN python -m venv $VENV_PATH

RUN --mount=type=cache,target=$POETRY_CACHE_DIR,id=${DEPOT_PROJECT}-poetry-cache,sharing=locked \
    . $VENV_PATH/bin/activate && \
    poetry lock && \
    poetry install --only=main --no-dev --no-root

COPY . .

RUN --mount=type=cache,target=$POETRY_CACHE_DIR,id=${DEPOT_PROJECT}-poetry-cache,sharing=locked \
    . $VENV_PATH/bin/activate && \
    poetry install --only-root

ENV PYTHONPATH=/opt/pysetup
RUN . $VENV_PATH/bin/activate && \
    python -m compileall -b $VENV_PATH/lib/python*/site-packages/ && \
    python -m compileall -b . && \
    find $VENV_PATH -name "*.py" -delete && \
    find . -name "*.py" -delete || true

FROM python:3.13-alpine AS runtime

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    VENV_PATH="/opt/venv" \
    PATH="/opt/venv/bin:$PATH"

RUN apk add --no-cache \
    dumb-init \
    curl

RUN addgroup -g 1001 -S appgroup && \
    adduser -S -u 1001 -G appgroup -h /app appuser

WORKDIR /app

COPY --from=build --chown=appuser:appgroup /opt/venv /opt/venv
COPY --from=build --chown=appuser:appgroup /opt/pysetup/ ./

USER appuser

HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

EXPOSE 8000

ENTRYPOINT ["dumb-init", "--"]
CMD ["python", "-m", "uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "4"]
```

## Explanation of the Dockerfile

This Dockerfile showcases an optimized approach for Python applications using Poetry, featuring bytecode compilation, multi-stage builds, and security best practices.

At a high level, here are the things we're optimizing in our Docker build for a Python application with Poetry:

- Multi-stage builds for smaller final images
- Poetry cache mounts for dependency caching
- Bytecode compilation for improved startup performance
- Security best practices with non-root users
- Health checks and process management

### Stage 1: `FROM python:3.13-alpine AS build`

```dockerfile
FROM python:3.13-alpine AS build

ENV POETRY_VERSION=1.7.1 \
    POETRY_HOME="/opt/poetry" \
    POETRY_VENV_IN_PROJECT=0 \
    POETRY_NO_INTERACTION=1 \
    POETRY_CACHE_DIR=/tmp/poetry_cache \
    PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PYSETUP_PATH="/opt/pysetup" \
    VENV_PATH="/opt/venv"

ENV PATH="$POETRY_HOME/bin:$VENV_PATH/bin:$PATH"
```

We start with Python 3.13 Alpine for a smaller base image and configure Poetry with specific environment variables:

- `POETRY_VERSION=1.7.1` pins the Poetry version for reproducible builds
- `POETRY_VENV_IN_PROJECT=0` prevents creating virtual environments inside the project
- `POETRY_NO_INTERACTION=1` disables interactive prompts
- `PYTHONUNBUFFERED=1` ensures logs are output in real-time

#### Installing build dependencies and Poetry

```dockerfile
RUN apk add --no-cache \
    build-base \
    curl \
    git \
    gcc \
    musl-dev \
    libffi-dev \
    pkgconfig

RUN --mount=type=cache,target=/root/.cache,id=${DEPOT_PROJECT}-pip-cache,sharing=locked \
    curl -sSL https://install.python-poetry.org | python - --version $POETRY_VERSION
```

We install build dependencies required for compiling Python packages and install Poetry using the official installer with cache mounts for efficiency.

#### Dependency installation and management

```dockerfile
WORKDIR $PYSETUP_PATH

COPY pyproject.toml ./

RUN python -m venv $VENV_PATH

RUN --mount=type=cache,target=$POETRY_CACHE_DIR,id=${DEPOT_PROJECT}-poetry-cache,sharing=locked \
    . $VENV_PATH/bin/activate && \
    poetry lock && \
    poetry install --only=main --no-dev --no-root
```

We create a virtual environment and install only production dependencies first. The `poetry lock` command ensures a consistent lock file, and `--only=main --no-dev --no-root` installs only production dependencies without the project itself.

#### Source code installation and optimization

```dockerfile
COPY . .

RUN --mount=type=cache,target=$POETRY_CACHE_DIR,id=${DEPOT_PROJECT}-poetry-cache,sharing=locked \
    . $VENV_PATH/bin/activate && \
    poetry install --only-root

ENV PYTHONPATH=/opt/pysetup
RUN . $VENV_PATH/bin/activate && \
    python -m compileall -b $VENV_PATH/lib/python*/site-packages/ && \
    python -m compileall -b . && \
    find $VENV_PATH -name "*.py" -delete && \
    find . -name "*.py" -delete || true
```

After copying the source code, we install the project itself and then compile all Python files to bytecode. This optimization improves startup performance and removes source files, leaving only the compiled bytecode.

### Stage 2: `FROM python:3.13-alpine AS runtime`

```dockerfile
FROM python:3.13-alpine AS runtime

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    VENV_PATH="/opt/venv" \
    PATH="/opt/venv/bin:$PATH"

RUN apk add --no-cache \
    dumb-init \
    curl

RUN addgroup -g 1001 -S appgroup && \
    adduser -S -u 1001 -G appgroup -h /app appuser
```

The runtime stage starts with a clean Alpine image and installs only the minimal runtime dependencies: `dumb-init` for proper signal handling and `curl` for health checks. We create a non-root user for security.

#### Final runtime configuration

```dockerfile
WORKDIR /app

COPY --from=build --chown=appuser:appgroup /opt/venv /opt/venv
COPY --from=build --chown=appuser:appgroup /opt/pysetup/ ./

USER appuser

HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

EXPOSE 8000

ENTRYPOINT ["dumb-init", "--"]
CMD ["python", "-m", "uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "4"]
```

We copy the compiled virtual environment and project files from the build stage, set proper ownership, switch to the non-root user, configure health checks, and use `dumb-init` for proper process management.

## Understanding BuildKit Cache Mounts

Cache mounts are one of the most powerful features for optimizing Docker builds with Depot. This Dockerfile uses multiple cache mounts:

```dockerfile
RUN --mount=type=cache,id=${DEPOT_PROJECT}-pip-cache,target=/root/.cache,sharing=locked \
    curl -sSL https://install.python-poetry.org | python - --version $POETRY_VERSION

RUN --mount=type=cache,id=${DEPOT_PROJECT}-poetry-cache,target=$POETRY_CACHE_DIR,sharing=locked \
    . $VENV_PATH/bin/activate && \
    poetry install --only=main --no-dev --no-root
```

### Cache Mount Parameters Explained

- **`type=cache`**: Specifies this is a cache mount that persists across builds.

- **`id=${DEPOT_PROJECT}-pip-cache`** / **`id=${DEPOT_PROJECT}-poetry-cache`**: Unique identifiers that:

  - Include `${DEPOT_PROJECT}` to isolate caches between different Python projects
  - Separate pip and Poetry caches for better management

- **`target=/root/.cache`**: Mount point for pip's cache directory.

- **`target=$POETRY_CACHE_DIR`**: Mount point for Poetry's cache (configured via environment variable).

- **`sharing=locked`**: Ensures exclusive access, preventing corruption from concurrent builds.

### Poetry-Specific Cache Strategy

This Dockerfile implements a dual-cache approach:

1. **Pip cache** (`/root/.cache`):

   - Used when installing Poetry itself
   - Caches Poetry's installation files

2. **Poetry cache** (`$POETRY_CACHE_DIR`):
   - Stores downloaded Python packages
   - Caches package metadata for dependency resolution
   - Speeds up lock file generation

### Bytecode Compilation Optimization

The Dockerfile also includes bytecode compilation:

```dockerfile
python -m compileall -b $VENV_PATH/lib/python*/site-packages/
```

This works synergistically with cache mounts:

- Compiled bytecode is part of the built image
- Source `.py` files are removed to reduce image size
- Startup performance is improved significantly
