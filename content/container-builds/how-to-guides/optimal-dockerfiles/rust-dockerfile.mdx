---
title: Best practice Dockerfile for Rust with cargo-chef and sccache
ogTitle: Best practice Dockerfile for Rust with cargo-chef and sccache
description: A sample best practice example Dockerfile for building images for Rust applications from us at Depot.
---

Below is an example `Dockerfile` that we have used and recommend at Depot for building images for Rust applications.

```dockerfile
# syntax=docker/dockerfile:1

FROM rust:1.89-alpine AS build

ARG DEPOT_PROJECT=my-app
ARG TARGETPLATFORM

RUN apk add --no-cache \
    pkgconfig \
    openssl-dev \
    openssl-libs-static \
    ca-certificates \
    musl-dev \
    gcc

RUN addgroup -g 1001 -S appgroup && \
    adduser -S -u 1001 -G appgroup -h /app appuser

RUN cargo install cargo-chef sccache --locked

RUN rustup target add $(uname -m)-unknown-linux-musl

WORKDIR /app

COPY Cargo.toml Cargo.lock ./

RUN cargo chef prepare --recipe-path recipe.json

ENV RUSTC_WRAPPER=sccache \
    SCCACHE_DIR=/sccache

RUN --mount=type=cache,id=${DEPOT_PROJECT}-cargo-reg-${TARGETPLATFORM:-linux-amd64},target=/usr/local/cargo/registry,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-cargo-git-${TARGETPLATFORM:-linux-amd64},target=/usr/local/cargo/git,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-cargo-target-${TARGETPLATFORM:-linux-amd64},target=/app/target,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-sccache-${TARGETPLATFORM:-linux-amd64},target=/sccache,sharing=locked \
    cargo chef cook --release --target $(uname -m)-unknown-linux-musl --recipe-path recipe.json

COPY . .

ENV RUSTFLAGS="-C target-feature=+crt-static"
RUN --mount=type=cache,id=${DEPOT_PROJECT}-cargo-reg-${TARGETPLATFORM:-linux-amd64},target=/usr/local/cargo/registry,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-cargo-git-${TARGETPLATFORM:-linux-amd64},target=/usr/local/cargo/git,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-cargo-target-${TARGETPLATFORM:-linux-amd64},target=/app/target,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-sccache-${TARGETPLATFORM:-linux-amd64},target=/sccache,sharing=locked \
    TARGET=$(uname -m)-unknown-linux-musl && \
    cargo build --release --target $TARGET --bin app && \
    cp target/$TARGET/release/app /usr/local/bin/app

FROM scratch AS runtime

COPY --from=build /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=build /etc/passwd /etc/passwd
COPY --from=build --chown=appuser:appgroup /usr/local/bin/app /usr/local/bin/app

USER appuser

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
    CMD ["/usr/local/bin/app", "--health-check"] || exit 1

ENTRYPOINT ["/usr/local/bin/app"]
```

## Using cargo-chef for dependency management

When you install multiple crates with one command like `cargo build`, Docker treats any change in the output of `cargo build` as a change to the **entire** command. This means that Docker will attempt to execute that command again (re-downloading and installing **all **crates) every time you make an unrelated change to your source code or Dockerfile.

There are various workarounds online to manually manage and copy individual packages into your container while building in order to avoid invalidating the cache on every build, but these are cumbersome and prone to bugs. Our preferred solution is to use [cargo-chef](https://github.com/LukeMathWalker/cargo-chef/blob/main/README.md), which allows you to separate building the dependencies and building the source code so that Docker sees them as different steps and can cache them separately.

## Using sccache for additional dependency management

Even though cargo-chef separates your third-party dependencies from your source code, compiling and downloading your third-party dependencies is still considered one operation. This means that if a single dependency changes, there will be a cache miss and all of them will have to be re-downloaded and compiled, even though they haven't changed.

If you have a more fine-grained cache, you only have to rebuild the changed dependencies. Enter [sccache](https://github.com/mozilla/sccache), which caches individual compilation artifacts so that they can be reused at a more granular level during future compilations. This allows you to recompile individual dependencies only when needed, rather than everything or nothing.

## Explanation of the Dockerfile

At a high level, here are the things we're optimizing in our Docker build for a Rust application:

- Multi-stage builds with Alpine base and scratch runtime
- cargo-chef for dependency separation and caching
- sccache for individual compilation artifact caching
- Cross-platform musl compilation with static linking
- BuildKit cache mounts with project and platform isolation
- Security best practices with non-root users

### Stage 1: `FROM rust:1.89-alpine AS build`

```dockerfile
FROM rust:1.89-alpine AS build

ARG DEPOT_PROJECT=my-app
ARG TARGETPLATFORM

RUN apk add --no-cache \
    pkgconfig \
    openssl-dev \
    openssl-libs-static \
    ca-certificates \
    musl-dev \
    gcc
```

We use Rust 1.89 Alpine as the base image for smaller size and faster builds. The build arguments enable project-specific cache isolation and cross-platform support. Essential packages are installed for musl compilation, including both dynamic and static OpenSSL libraries.

#### User setup and tool installation

```dockerfile
RUN addgroup -g 1001 -S appgroup && \
    adduser -S -u 1001 -G appgroup -h /app appuser

RUN cargo install cargo-chef sccache --locked

RUN rustup target add $(uname -m)-unknown-linux-musl
```

We create a non-root user for security, install both cargo-chef for dependency management and sccache for compilation artifact caching, and add the musl target for static compilation.

#### Dependency preparation with cargo-chef

```dockerfile
WORKDIR /app

COPY Cargo.toml Cargo.lock ./

RUN cargo chef prepare --recipe-path recipe.json
```

cargo-chef creates a recipe from the dependency files, enabling Docker to cache dependency builds separately from source code changes.

#### sccache configuration

```dockerfile
ENV RUSTC_WRAPPER=sccache \
    SCCACHE_DIR=/sccache
```

We configure sccache by setting `RUSTC_WRAPPER=sccache` to wrap Rust compiler calls and `SCCACHE_DIR=/sccache` to specify the cache directory location.

#### Dependency compilation with comprehensive cache mounts

```dockerfile
RUN --mount=type=cache,id=${DEPOT_PROJECT}-cargo-reg-${TARGETPLATFORM:-linux-amd64},target=/usr/local/cargo/registry,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-cargo-git-${TARGETPLATFORM:-linux-amd64},target=/usr/local/cargo/git,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-cargo-target-${TARGETPLATFORM:-linux-amd64},target=/app/target,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-sccache-${TARGETPLATFORM:-linux-amd64},target=/sccache,sharing=locked \
    cargo chef cook --release --target $(uname -m)-unknown-linux-musl --recipe-path recipe.json
```

Dependencies are compiled using cargo-chef with four types of cache mounts:

- Registry cache: Downloaded crate files
- Git cache: Git-based dependencies
- Target cache: Compiled artifacts
- sccache: Individual compilation artifacts

#### Application compilation

```dockerfile
COPY . .

ENV RUSTFLAGS="-C target-feature=+crt-static"
RUN --mount=type=cache,id=${DEPOT_PROJECT}-cargo-reg-${TARGETPLATFORM:-linux-amd64},target=/usr/local/cargo/registry,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-cargo-git-${TARGETPLATFORM:-linux-amd64},target=/usr/local/cargo/git,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-cargo-target-${TARGETPLATFORM:-linux-amd64},target=/app/target,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-sccache-${TARGETPLATFORM:-linux-amd64},target=/sccache,sharing=locked \
    TARGET=$(uname -m)-unknown-linux-musl && \
    cargo build --release --target $TARGET --bin app && \
    cp target/$TARGET/release/app /usr/local/bin/app
```

The application is compiled with static linking enabled, using the same cache mounts as dependency compilation. This ensures that sccache can reuse compilation artifacts between dependency and application builds. The binary is copied to a standard location for the next stage.

### Stage 2: `FROM scratch AS runtime`

```dockerfile
FROM scratch AS runtime

COPY --from=build /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=build /etc/passwd /etc/passwd
COPY --from=build --chown=appuser:appgroup /usr/local/bin/app /usr/local/bin/app

USER appuser

EXPOSE 8080

HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
    CMD ["/usr/local/bin/app", "--health-check"] || exit 1

ENTRYPOINT ["/usr/local/bin/app"]
```

The runtime stage uses a scratch image for minimal size, copying only:

- SSL certificates for HTTPS connections
- User information for non-root execution
- The compiled application binary

## Understanding BuildKit Cache Mounts

Cache mounts are one of the most powerful features for optimizing Docker builds with Depot. This Dockerfile uses the following cache mount syntax:

```dockerfile
RUN --mount=type=cache,id=${DEPOT_PROJECT}-cargo-reg-${TARGETPLATFORM:-linux-amd64},target=/usr/local/cargo/registry,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-cargo-git-${TARGETPLATFORM:-linux-amd64},target=/usr/local/cargo/git,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-cargo-target-${TARGETPLATFORM:-linux-amd64},target=/app/target,sharing=locked \
    --mount=type=cache,id=${DEPOT_PROJECT}-sccache-${TARGETPLATFORM:-linux-amd64},target=/sccache,sharing=locked \
    cargo chef cook --release --target $(uname -m)-unknown-linux-musl --recipe-path recipe.json
```

### Cache Mount Parameters Explained

- **`type=cache`**: Specifies this is a cache mount that persists across builds.

- **`id=${DEPOT_PROJECT}-cargo-reg-${TARGETPLATFORM:-linux-amd64}`**: A unique identifier that:

  - Includes `${DEPOT_PROJECT}` to isolate Cargo caches between different Rust projects
  - Uses `${TARGETPLATFORM}` for multi-architecture builds (AMD64, ARM64)
  - Defaults to `linux-amd64` if TARGETPLATFORM is not set

- **Multiple cache targets**:

  - **`/usr/local/cargo/registry`**: Cargo package registry cache
  - **`/usr/local/cargo/git`**: Git-based dependency cache
  - **`/app/target`**: Compiled artifact cache
  - **`/sccache`**: sccache compilation artifact cache

- **`sharing=locked`**: Ensures exclusive access during compilation, preventing cache corruption.

### Rust-Specific Cache Strategy

This Dockerfile implements a four-tier caching approach:

1. **Registry cache** (`/usr/local/cargo/registry`):

   - Downloaded crate files from crates.io
   - Package metadata and version information
   - Eliminates repeated downloads

2. **Git cache** (`/usr/local/cargo/git`):

   - Git-based dependencies and their metadata
   - Supports dependencies from GitHub, GitLab, etc.
   - Preserves git history for incremental updates

3. **Target cache** (`/app/target`):

   - Compiled Rust artifacts and object files
   - Enables incremental compilation
   - Dramatically speeds up rebuilds

4. **sccache** (`/sccache`):
   - Individual compilation artifacts from rustc
   - Enables fine-grained caching at the compiler level
   - Reuses artifacts across different build contexts

### cargo-chef and sccache Integration Benefits

The combination of cargo-chef, sccache, and cache mounts provides:

- Dependencies built independently from source code
- Docker layer caching for dependency recipes
- Fine-grained compilation artifact caching
- Build artifact caching across source changes
- Platform-specific caches for cross-compilation

## Using cargo-chef for dependency management

cargo-chef solves a fundamental caching problem in Rust Docker builds. When you run `cargo build`, Docker treats the entire compilation as a single operation. Any change to your source code invalidates the cache and forces recompilation of all dependencies.

[cargo-chef](https://github.com/LukeMathWalker/cargo-chef) separates dependency compilation from source compilation by:

1. **`cargo chef prepare`**: Analyzes `Cargo.toml` and `Cargo.lock` to create a dependency recipe
2. **`cargo chef cook`**: Compiles only the dependencies based on the recipe
3. **`cargo build`**: Compiles the application code using cached dependencies

This separation allows Docker to cache dependency compilation independently, only rebuilding dependencies when they actually change.

## Using sccache for additional optimization

Even with cargo-chef separating dependencies from source code, compiling dependencies is still treated as a single operation. If a single dependency changes, all dependencies need to be recompiled.

[sccache](https://github.com/mozilla/sccache) provides fine-grained caching at the compiler level by:

1. **Wrapping rustc calls**: The `RUSTC_WRAPPER=sccache` environment variable intercepts compiler invocations
2. **Caching compilation artifacts**: Individual object files and compilation outputs are cached
3. **Reusing artifacts**: Unchanged code can reuse cached compilation results
4. **Cross-context sharing**: Artifacts can be shared between dependency and application builds

This means only the specific crates that have changed need to be recompiled, while unchanged crates can reuse their cached artifacts.

## Cross-platform musl compilation

The Dockerfile targets musl libc instead of glibc for several advantages:

- **Static linking**: Creates self-contained binaries with no runtime dependencies
- **Smaller images**: Enables use of scratch base images
- **Portability**: Binaries work across different Linux distributions
- **Security**: Reduced attack surface with minimal runtime components

The `RUSTFLAGS="-C target-feature=+crt-static"` ensures complete static linking for maximum portability.
