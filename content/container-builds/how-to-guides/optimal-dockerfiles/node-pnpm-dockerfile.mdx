---
title: Best practice Dockerfile for Node.js with pnpm
ogTitle: Best practice Dockerfile for Node.js with pnpm
description: A sample best practice pnpm Dockerfile for Node.js from us at Depot
---

Below is an example `Dockerfile` that we use and recommend at Depot when we are building Docker images for Node applications that use `pnpm` as their package manager.

```dockerfile
# syntax=docker/dockerfile:1

FROM node:22-alpine AS build

ARG DEPOT_PROJECT=my-app

RUN corepack enable && \
    corepack prepare pnpm@latest --activate

ENV PNPM_HOME="/pnpm"
ENV PATH="$PNPM_HOME:$PATH"

WORKDIR /app

COPY pnpm-lock.yaml package.json ./

RUN --mount=type=cache,id=${DEPOT_PROJECT}-pnpm,target=/pnpm/store \
    pnpm fetch --frozen-lockfile

RUN --mount=type=cache,id=${DEPOT_PROJECT}-pnpm,target=/pnpm/store \
    pnpm install --frozen-lockfile --prod --offline

RUN apk add --no-cache python3 make g++

COPY pnpm-lock.yaml package.json ./

RUN --mount=type=cache,id=${DEPOT_PROJECT}-pnpm-build,target=/pnpm/store \
    pnpm fetch --frozen-lockfile

RUN --mount=type=cache,id=${DEPOT_PROJECT}-pnpm-build,target=/pnpm/store \
    pnpm install --frozen-lockfile --offline

COPY . .

RUN pnpm build

FROM node:22-alpine AS runtime

RUN addgroup -g 1001 -S appgroup && \
    adduser -S -u 1001 -G appgroup -h /app appuser

WORKDIR /app

COPY --from=build /app/public ./public
COPY --from=build --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=build --chown=nextjs:nodejs /app/.next/static ./.next/static

ENV NODE_ENV=production \
    NODE_OPTIONS="--max-old-space-size=1024 --unhandled-rejections=strict"

USER appuser

EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1

ENTRYPOINT ["node", "server.js"]
```

## Explanation of the Dockerfile

This Dockerfile uses an optimized multi-stage build approach that leverages pnpm's features for efficient dependency management and caching. We use Node.js 22 Alpine for smaller image sizes and implement security best practices.

At a high level, here are the things we're optimizing in our Docker build for a Node.js application with pnpm:

- Multi-stage builds via multiple `FROM` statements
- pnpm cache mounts for dependency caching
- Offline installation for improved reliability
- Security best practices with non-root users
- Health checks for container monitoring

### Stage 1: `FROM node:22-alpine AS build`

```dockerfile
FROM node:22-alpine AS build

ARG DEPOT_PROJECT=my-app

RUN corepack enable && \
    corepack prepare pnpm@latest --activate

ENV PNPM_HOME="/pnpm"
ENV PATH="$PNPM_HOME:$PATH"

WORKDIR /app
```

We start with the latest LTS Node.js Alpine image for a smaller base. The `DEPOT_PROJECT` build argument allows for project-specific cache isolation when building multiple applications. We enable [`corepack`](https://nodejs.org/api/corepack.html) and prepare the latest pnpm version. Corepack allows us to use pnpm without manual installation, and we set up the proper environment variables for pnpm's home directory.

#### Production dependency installation

```dockerfile
COPY pnpm-lock.yaml package.json ./

RUN --mount=type=cache,id=${DEPOT_PROJECT}-pnpm,target=/pnpm/store \
    pnpm fetch --frozen-lockfile

RUN --mount=type=cache,id=${DEPOT_PROJECT}-pnpm,target=/pnpm/store \
    pnpm install --frozen-lockfile --prod --offline
```

We copy only the package files first to leverage Docker's layer caching. The installation process uses two optimized commands:

1. `pnpm fetch --frozen-lockfile` is a [pnpm feature](https://pnpm.io/cli/fetch) that fetches packages from the lockfile into the pnpm store without installing them. This optimizes the Docker layer cache.

2. `pnpm install --frozen-lockfile --prod --offline` installs only production dependencies using the cached packages from the previous step. The `--offline` flag ensures we use only cached packages.

#### Build dependency installation

```dockerfile
RUN apk add --no-cache python3 make g++

COPY pnpm-lock.yaml package.json ./

RUN --mount=type=cache,id=${DEPOT_PROJECT}-pnpm-build,target=/pnpm/store \
    pnpm fetch --frozen-lockfile

RUN --mount=type=cache,id=${DEPOT_PROJECT}-pnpm-build,target=/pnpm/store \
    pnpm install --frozen-lockfile --offline
```

For packages requiring native compilation, we install build tools. We then repeat the fetch and install process for all dependencies (including dev dependencies) needed for building.

#### Building the application

```dockerfile
COPY . .

RUN pnpm build
```

After copying the source code, we build the application using pnpm.

### Stage 2: `FROM node:22-alpine AS runtime`

```dockerfile
FROM node:22-alpine AS runtime

RUN addgroup -g 1001 -S appgroup && \
    adduser -S -u 1001 -G appgroup -h /app appuser

WORKDIR /app

COPY --from=build /app/public ./public
COPY --from=build --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=build --chown=nextjs:nodejs /app/.next/static ./.next/static
```

The runtime stage starts fresh with a clean Alpine image and creates a non-root user for security. We copy only the built application files from the build stage, setting appropriate ownership.

#### Runtime configuration

```dockerfile
ENV NODE_ENV=production \
    NODE_OPTIONS="--max-old-space-size=1024 --unhandled-rejections=strict"

USER appuser

EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1

ENTRYPOINT ["node", "server.js"]
```

We set production environment variables with memory limits and strict error handling, switch to the non-root user for security, expose the application port, and configure a health check for container orchestration.

## Understanding BuildKit Cache Mounts

Cache mounts are one of the most powerful features for optimizing Docker builds with Depot. This Dockerfile uses the following cache mount syntax:

```dockerfile
RUN --mount=type=cache,id=${DEPOT_PROJECT}-pnpm,target=/pnpm/store \
    pnpm fetch --frozen-lockfile
```

### Cache Mount Parameters Explained

- **`type=cache`**: Specifies this is a cache mount. The cache persists across builds and is managed by BuildKit (and Depot's distributed cache system).

- **`id=${DEPOT_PROJECT}-pnpm`**: A unique identifier for this cache. The `${DEPOT_PROJECT}` variable ensures different projects don't share caches, preventing conflicts. This is especially important for pnpm's content-addressable storage.

- **`target=/pnpm/store`**: The mount point inside the container where pnpm's store is located. Unlike npm, pnpm uses a content-addressable store that can be shared efficiently across projects.

- **`sharing=locked`** (optional): When specified, ensures exclusive access to the cache during operations, preventing corruption from concurrent builds.

### pnpm-Specific Optimizations

pnpm's architecture makes it particularly well-suited for cache mounts:

1. **Content-addressable store**: Packages are stored once and hard-linked, making the cache highly efficient
2. **Deterministic installs**: The `--frozen-lockfile` flag ensures reproducible builds
3. **Offline mode**: The `--offline` flag in subsequent installs uses only cached packages, eliminating network requests
